<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æŠ“ç…¤çƒ - è¾¹ç¼˜è¿›åœºç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; touch-action: none; font-family: sans-serif; }
        canvas { display: block; }
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center;
            color: white; font-size: 24px; z-index: 10; cursor: pointer;
            flex-direction: column;
        }
        #score-board {
            position: absolute; top: 10px; left: 10px; font-size: 20px; font-weight: bold; color: #333; pointer-events: none;
            background: rgba(255,255,255,0.5); padding: 5px 10px; border-radius: 10px;
        }
        .instruction { font-size: 14px; margin-top: 10px; color: #ccc; }
    </style>
</head>
<body>

<div id="score-board">æŠ“è·: 0</div>
<div id="start-overlay">
    <div>ç‚¹å‡»å±å¹•å¼€å§‹</div>
    <div class="instruction">ä»è¾¹ç¼˜çˆ¬å…¥ -> è§‚å¯Ÿ -> ç§»åŠ¨</div>
</div>
<canvas id="gameCanvas"></canvas>

<script>
const CONFIG = {
    MAX_COUNT: 1,         
    SPAWN_DELAY: 1500,    
    GOLD_CHANCE: 0.05,    
    WANDER_SPEED: 2.0,    
    SPRINT_SPEED: 9.0,    
    RUN_SPEED: 13.0,      
    STOP_SOUND_THRESHOLD: 3.5, 
    SCARE_RADIUS: 180,    
    HIT_RADIUS: 60,
    OBSERVE_TIME: 60,     // è§‚å¯Ÿ 60 å¸§ (çº¦1ç§’)
    SAFE_MARGIN: 120      // è¿›åœºæ—¶ï¼Œå¿…é¡»çˆ¬è¿›å±å¹•å¤šå°‘è·ç¦»æ‰å¼€å§‹è§‚å¯Ÿ
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let score = 0;
let gameRunning = false;
let nextSpawnTime = 0;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- ğŸµ éŸ³æ•ˆç®¡ç†å™¨ ---
const SoundMgr = {
    s_appear: new Audio('./ap.mp3'),
    s_move: new Audio('./move.mp3'),
    ctx: null,

    init: function() { 
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.s_appear.load();
        this.s_move.load();
        this.s_move.loop = true; 
    },
    
    playAppear: function() {
        this.s_appear.currentTime = 0;
        this.s_appear.play().catch(e=>{});
    },
    
    ensurePlaying: function() {
        if (this.s_move.paused) {
            this.s_move.play().catch(e=>{});
        }
    },

    ensureStopped: function() {
        if (!this.s_move.paused) {
            this.s_move.pause();
            this.s_move.currentTime = 0; 
        }
    },

    playPop: function() { 
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + 0.1);
    },
    
    playGold: function() {
        if(!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1500, t);
        gain.gain.setValueAtTime(0.2, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(t + 0.5);
    }
};

// --- è§†è§‰ç‰¹æ•ˆ ---
class PawPrint {
    constructor(x, y) {
        this.x = x; this.y = y; this.life = 1.0; this.angle = Math.random()*6.28;
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.globalAlpha = this.life; ctx.fillStyle = 'rgba(255, 182, 193, 0.8)';
        ctx.beginPath(); ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI*2); ctx.fill();
        [[-18,-20],[-6,-28],[6,-28],[18,-20]].forEach(t=>{
            ctx.beginPath(); ctx.arc(t[0],t[1],8,0,Math.PI*2); ctx.fill();
        });
        ctx.restore(); this.life -= 0.01;
    }
}

class Particle {
    constructor(x, y, isGold) {
        this.x = x; this.y = y; this.isGold = isGold;
        this.size = Math.random()*4+2; this.life = 1.0;
        this.vx = (Math.random()-0.5)*3; this.vy = (Math.random()-0.5)*3;
    }
    update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.03; this.size*=0.9; }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.isGold ? '#FFD700' : '#333';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// --- ç…¤çƒç±» ---
class CoalBall {
    constructor() {
        this.sprintCounter = 0; 
        this.reset(true);
    }

    reset(isFirstSpawn) {
        this.isGold = Math.random() < CONFIG.GOLD_CHANCE;
        this.radius = 40 + Math.random() * 10;
        
        // ã€ä¿®æ”¹ç‚¹ã€‘1. éšæœºä»4ä¸ªè¾¹ç¼˜å¤–ç”Ÿæˆ
        const edge = Math.floor(Math.random() * 4); // 0:ä¸Š, 1:å³, 2:ä¸‹, 3:å·¦
        const offset = 60; // ç¨å¾®åœ¨å±å¹•å¤–ä¸€ç‚¹
        
        if (edge === 0) { // Top
            this.x = Math.random() * canvas.width; 
            this.y = -offset;
        } else if (edge === 1) { // Right
            this.x = canvas.width + offset; 
            this.y = Math.random() * canvas.height;
        } else if (edge === 2) { // Bottom
            this.x = Math.random() * canvas.width; 
            this.y = canvas.height + offset;
        } else { // Left
            this.x = -offset; 
            this.y = Math.random() * canvas.height;
        }

        // åˆå§‹çŠ¶æ€è®¾ä¸º "ENTERING" (è¿›åœº)
        this.state = 'ENTERING';
        this.visible = true;
        this.scale = 1; // æ—¢ç„¶æ˜¯ä»å¤–é¢çˆ¬è¿›æ¥ï¼Œå°±ä¸éœ€è¦ä»å°å˜å¤§çš„åŠ¨ç”»äº†
        
        // è®¡ç®—ä¸€ä¸ªæŒ‡å‘å±å¹•ä¸­å¿ƒåéšæœºä¸€ç‚¹çš„è§’åº¦ï¼Œç¡®ä¿å®ƒçˆ¬è¿›æ¥
        let centerX = canvas.width / 2 + (Math.random()-0.5) * 200;
        let centerY = canvas.height / 2 + (Math.random()-0.5) * 200;
        this.angle = Math.atan2(centerY - this.y, centerX - this.x);
        
        // æ’­æ”¾å£°éŸ³
        SoundMgr.playAppear();

        this.speed = CONFIG.WANDER_SPEED;
        this.wanderTimer = 0;
        this.timer = 0;
        this.blinkTimer = Math.random() * 200;
        this.eyeOffset = 0;
        
        // è§‚å¯Ÿå€’è®¡æ—¶
        this.observeTimer = CONFIG.OBSERVE_TIME;
        
        this.isHidingRun = false; 
        this.hiddenTimer = 0;
    }

    triggerSprint(sourceX, sourceY) {
        if (this.state === 'SCARE' || this.state === 'HIDDEN' || this.state === 'ENTERING') return;

        this.sprintCounter++;
        
        if (this.sprintCounter % 3 === 0) {
            this.isHidingRun = true;
            this.speed = (sourceX ? CONFIG.RUN_SPEED : CONFIG.SPRINT_SPEED) * 1.2;
        } else {
            this.isHidingRun = false;
            this.speed = (sourceX ? CONFIG.RUN_SPEED : CONFIG.SPRINT_SPEED) * (this.isGold ? 1.5 : 1);
        }

        if (sourceX !== undefined) {
            this.angle = Math.atan2(this.y - sourceY, this.x - sourceX) + (Math.random()-0.5);
        } else {
            this.angle += (Math.random() - 0.5);
        }

        this.state = 'SCARE';
    }

    update() {
        if (this.state === 'HIDDEN') {
            this.hiddenTimer--;
            if (this.hiddenTimer <= 0) this.reset(false);
            return;
        }

        if (!this.visible) return; 

        this.timer++;

        // --- çŠ¶æ€æœºé€»è¾‘ ---

        // 1. ENTERING (çˆ¬è¿›åœº)
        if (this.state === 'ENTERING') {
            this.speed = CONFIG.WANDER_SPEED; // æ­£å¸¸çˆ¬è¡Œé€Ÿåº¦
            
            // æ£€æµ‹æ˜¯å¦å·²ç»è¿›å…¥â€œå®‰å…¨åŒºâ€ï¼ˆå³ç¦»è¾¹ç¼˜æœ‰ä¸€å®šè·ç¦»ï¼‰
            let inSafeZone = (
                this.x > CONFIG.SAFE_MARGIN && 
                this.x < canvas.width - CONFIG.SAFE_MARGIN &&
                this.y > CONFIG.SAFE_MARGIN &&
                this.y < canvas.height - CONFIG.SAFE_MARGIN
            );

            if (inSafeZone) {
                // åˆ°ä½äº†ï¼Œåˆ¹è½¦ï¼Œå¼€å§‹è§‚å¯Ÿ
                this.state = 'OBSERVING';
                this.speed = 0;
            }
        }
        
        // 2. OBSERVING (åœä¸‹è§‚å¯Ÿ)
        else if (this.state === 'OBSERVING') {
            this.speed = 0;
            this.observeTimer--;
            this.eyeOffset = Math.sin(this.timer / 10) * 8; // å·¦å³çœ‹
            
            if (this.observeTimer <= 0) {
                this.state = 'WANDER';
                // è§‚å¯Ÿå®Œï¼Œé€‰ä¸ªæ–°æ–¹å‘å¼€å§‹èµ°
                this.angle += (Math.random() - 0.5);
            }
        }

        // 3. WANDER (æ­£å¸¸æ¸¸è¡)
        else if (this.state === 'WANDER') {
            this.speed = CONFIG.WANDER_SPEED;
            this.wanderTimer--;
            if (this.wanderTimer <= 0) {
                this.angle += (Math.random() - 0.5) * 3.0; 
                this.wanderTimer = 40 + Math.random() * 60;
                
                if (Math.random() < 0.25) this.triggerSprint(); 
            }
            
            // ç¢°å£æ£€æµ‹ï¼ˆä»…åœ¨éèº²è—æ¨¡å¼ä¸‹ï¼‰
            if (!this.isHidingRun) {
                if (this.x < 50) this.angle = 0 + Math.random();
                if (this.x > canvas.width - 50) this.angle = Math.PI + Math.random();
                if (this.y < 50) this.angle = Math.PI/2 + Math.random();
                if (this.y > canvas.height - 50) this.angle = -Math.PI/2 + Math.random();
            }

            this.eyeOffset = Math.sin(this.timer/40) * 6; 
        }

        // 4. SCARE (å†²åˆº/é€ƒè·‘)
        else if (this.state === 'SCARE') {
            if (!this.isHidingRun) {
                this.speed *= 0.96; 
                if (this.speed < CONFIG.WANDER_SPEED + 1) this.state = 'WANDER';
            } else {
                // èº²è—æ¨¡å¼ï¼šè·‘å‡ºå±å¹•æ£€æµ‹
                if (this.x < -100 || this.x > canvas.width + 100 || 
                    this.y < -100 || this.y > canvas.height + 100) {
                    this.state = 'HIDDEN';
                    this.visible = false;
                    SoundMgr.ensureStopped(); 
                    this.hiddenTimer = (2 + Math.random() * 3) * 60;
                    return;
                }
            }
            if (Math.random() > 0.4) particles.push(new Particle(this.x, this.y, this.isGold));
            this.eyeOffset = 0;
        }

        // --- éŸ³æ•ˆæ§åˆ¶ ---
        // è§‚å¯Ÿå’Œè¿›åœºæ…¢çˆ¬æ—¶æ²¡å£°éŸ³ï¼Œåªæœ‰è·‘å¾—å¿«æ‰æœ‰å£°éŸ³
        if (this.speed > CONFIG.STOP_SOUND_THRESHOLD) {
            SoundMgr.ensurePlaying();
        } else {
            SoundMgr.ensureStopped();
        }

        // --- ç‰©ç†ç§»åŠ¨ ---
        // è§‚å¯ŸçŠ¶æ€ä¸è •åŠ¨
        let wiggle = (this.state === 'OBSERVING') ? 0 : Math.sin(this.timer / 4) * 2;
        this.x += Math.cos(this.angle) * this.speed - Math.sin(this.angle) * wiggle;
        this.y += Math.sin(this.angle) * this.speed + Math.cos(this.angle) * wiggle;

        this.blinkTimer--;
        if (this.blinkTimer <= 0) this.blinkTimer = 100 + Math.random() * 300;
    }

    draw(ctx) {
        if (!this.visible || this.state === 'HIDDEN') return;

        ctx.save();
        ctx.translate(this.x, this.y);

        let stretch = Math.min(this.speed / 15, 0.4); 
        let drawAngle = (this.speed > 0.5) ? this.angle : 0;
        
        ctx.rotate(drawAngle);
        ctx.scale(this.scale * (1 + stretch), this.scale * (1 - stretch));

        // å°¾å·´
        ctx.beginPath();
        ctx.moveTo(-this.radius+10, 0);
        ctx.quadraticCurveTo(-this.radius*2, Math.sin(this.timer/5)*12, -this.radius*2.8, 0);
        ctx.lineWidth = 7; ctx.strokeStyle = this.isGold?'#DAA520':'#333'; ctx.lineCap='round'; ctx.stroke();

        // èº«ä½“
        ctx.fillStyle = this.isGold ? '#FFD700' : 'black';
        ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();

        // çœ¼ç›
        let isBlinking = this.blinkTimer < 5;
        let eyeScale = (this.state === 'SCARE') ? 1.4 : 1;
        
        if (!isBlinking) {
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.ellipse(12, -9, 9*eyeScale, 7*eyeScale, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(12, 9, 9*eyeScale, 7*eyeScale, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'black';
            let pX = 14 + this.eyeOffset;
            ctx.beginPath(); ctx.arc(pX, -9, 3.5, 0, Math.PI*2); ctx.arc(pX, 9, 3.5, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.strokeStyle = '#666'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(5,-9); ctx.lineTo(19,-9); ctx.moveTo(5,9); ctx.lineTo(19,9); ctx.stroke();
        }

        ctx.restore();
    }

    checkInput(ix, iy) {
        if (!this.visible || this.state === 'HIDDEN') return 'MISS';

        let dist = Math.sqrt((ix-this.x)**2 + (iy-this.y)**2);
        
        if (dist < CONFIG.HIT_RADIUS) return 'HIT';
        if (dist < CONFIG.SCARE_RADIUS) {
            this.triggerSprint(ix, iy);
            return 'SCARE';
        }
        return 'MISS';
    }
}

// --- æ¸¸æˆå¾ªç¯ ---
let coalBalls = [];
let particles = [];
let paws = [];

function loop() {
    if (!gameRunning) { requestAnimationFrame(loop); return; }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let now = Date.now();

    if (coalBalls.length < CONFIG.MAX_COUNT && now > nextSpawnTime) {
        coalBalls.push(new CoalBall());
    }

    for(let i=paws.length-1; i>=0; i--) {
        paws[i].draw(ctx);
        if(paws[i].life <= 0) paws.splice(i, 1);
    }
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].update(); particles[i].draw(ctx);
        if(particles[i].life <= 0) particles.splice(i, 1);
    }
    for(let i=coalBalls.length-1; i>=0; i--) {
        let ball = coalBalls[i];
        ball.update();
        ball.draw(ctx);
        if(ball.dead) coalBalls.splice(i, 1);
    }

    document.getElementById('score-board').innerText = `æŠ“è·: ${score}`;
    requestAnimationFrame(loop);
}

function handleInput(x, y) {
    if (!gameRunning) return;
    paws.push(new PawPrint(x, y));
    
    for (let i = coalBalls.length - 1; i >= 0; i--) {
        let res = coalBalls[i].checkInput(x, y);
        if (res === 'HIT') {
            SoundMgr.ensureStopped();
            if (coalBalls[i].isGold) SoundMgr.playGold();
            else SoundMgr.playPop();
            score++;
            coalBalls[i].dead = true;
            nextSpawnTime = Date.now() + CONFIG.SPAWN_DELAY;
        }
    }
}

document.getElementById('start-overlay').addEventListener('click', function() {
    this.style.display = 'none';
    SoundMgr.init();
    gameRunning = true;
    nextSpawnTime = Date.now();
});

canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for(let t of e.touches) handleInput(t.clientX, t.clientY);
}, {passive: false});

loop();
</script>
</body>
</html>
